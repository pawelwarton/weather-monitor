CREATE TABLE measures (
        id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        sensor_id VARCHAR(256) NOT NULL,
        city_id   VARCHAR(256) NOT NULL,
        pm10      DECIMAL NOT NULL,
        co        DECIMAL NOT NULL,
        no2       DECIMAL NOT NULL,
        timestamp TIMESTAMP WITH TIME ZONE NOT NULL
);
CREATE INDEX idx_measures_timestamp ON measures (timestamp);
CREATE INDEX idx_measures_city      ON measures (city_id);


CREATE TABLE cities (
    id           VARCHAR(256) PRIMARY KEY,
    name         VARCHAR(1024) NOT NULL,
    region_id    VARCHAR(256) NOT NULL,
    region_name  VARCHAR(256) NOT NULL,
    country_name VARCHAR(256) NOT NULL
);
CREATE INDEX idx_cities_region_id   ON cities (region_id);


CREATE VIEW worst_cities_pm10
AS
WITH raw_worst_cities_pm10 AS (
    SELECT city_id, AVG(pm10) avg_pm10
    FROM measures
    WHERE EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla pierwszego dnia poprzedniego miesiąca
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' + INTERVAL '1 day'
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla ostatniego dnia poprzedniego miesiąca
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 day'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE)
    )
    AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'
    AND timestamp <  DATE_TRUNC('month', CURRENT_DATE)
    GROUP BY city_id
    ORDER BY avg_pm10 DESC
    LIMIT 100
)
SELECT c.name AS city_name, c.region_name AS region_name, rwcp.avg_pm10 AS avg_pm10
FROM raw_worst_cities_pm10 AS rwcp
JOIN cities AS c ON c.id = rwcp.city_id;


CREATE VIEW worst_countries_co
AS
WITH worst_cities_co AS (
    SELECT city_id, AVG(co) avg_co
    FROM measures
    WHERE EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla pierwszego dnia poprzedniego miesiąca
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' + INTERVAL '1 day'
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla ostatniego dnia poprzedniego miesiąca
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 day'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE)
    )
    AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'
    AND timestamp <  DATE_TRUNC('month', CURRENT_DATE)
    GROUP BY city_id
    ORDER BY avg_co DESC
    LIMIT 10
)
SELECT country_name, COUNT(*) as city_count
FROM worst_cities_co wcc
JOIN cities c ON c.id = wcc.city_id
GROUP BY country_name
HAVING COUNT(*) > 1;


CREATE VIEW worst_cities_no2_y2y
AS
WITH cities_no2_y2y AS (
    SELECT city_id,
           AVG(CASE WHEN DATE_TRUNC('month', timestamp) = DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'        THEN no2 ELSE null END) avg_no2_current,
           AVG(CASE WHEN DATE_TRUNC('month', timestamp) = DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 year 1 month' THEN no2 ELSE null END) avg_no2_year_before
    FROM measures
    WHERE EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla pierwszego dnia poprzedniego miesiąca
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' + INTERVAL '1 day'
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla ostatniego dnia poprzedniego miesiąca
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 day'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE)
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla pierwszego dnia poprzedniego miesiąca, poprzedniego roku
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 year 1 month'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 year 1 month' + INTERVAL '1 day'
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla ostatniego dnia poprzedniego miesiąca, poprzedniego roku
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 year 1 day'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 year'
    )
    AND (
        (
            -- poprzedni miesiąc tego roku
                timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'
            AND timestamp <  DATE_TRUNC('month', CURRENT_DATE)
        )
        OR
        (
            -- poprzedni miesiąc poprzedniego roku
                timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 year 1 month'
            AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 year'
        )
    )
    GROUP BY city_id
)
SELECT y2y.city_id,
       c.name AS city_name,
       c.country_name,
       y2y.avg_no2_current,
       y2y.avg_no2_year_before
FROM cities_no2_y2y y2y
JOIN cities c ON c.id = y2y.city_id
WHERE y2y.avg_no2_current > y2y.avg_no2_year_before;


CREATE VIEW last_hour
AS
SELECT city_id,
       MIN(no2)  min_no2_last_hour,  AVG(no2) avg_no2_last_hour,   MAX(no2)  max_no2_last_hour,
       MIN(co)   min_co_last_hour,   AVG(co) avg_co_last_hour,     MAX(co)   max_co_last_hour,
       MIN(pm10) min_pm10_last_hour, AVG(pm10) avg_pm10_last_hour, MAX(pm10) max_pm10_last_hour
FROM measures
WHERE timestamp > (CURRENT_TIMESTAMP - INTERVAL '1 hour')
GROUP BY city_id;


CREATE VIEW rising_co_or_pm10_3m_cities
AS
WITH last_3m_cities AS (
    SELECT city_id,
           AVG(CASE WHEN DATE_TRUNC('month', timestamp) = DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' THEN co ELSE null END) co_1m,
           AVG(CASE WHEN DATE_TRUNC('month', timestamp) = DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 month' THEN co ELSE null END) co_2m,
           AVG(CASE WHEN DATE_TRUNC('month', timestamp) = DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '3 month' THEN co ELSE null END) co_3m,
           AVG(CASE WHEN DATE_TRUNC('month', timestamp) = DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' THEN pm10 ELSE null END) pm10_1m,
           AVG(CASE WHEN DATE_TRUNC('month', timestamp) = DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 month' THEN pm10 ELSE null END) pm10_2m,
           AVG(CASE WHEN DATE_TRUNC('month', timestamp) = DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '3 month' THEN pm10 ELSE null END) pm10_3m
    FROM measures
    WHERE EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla pierwszygo dnia miesiąca - 1
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month' + INTERVAL '1 day'
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla ostatniego dnia miesiąca - 1
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 day'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE)
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla pierwszygo dnia miesiąca - 2
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 month'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 month' + INTERVAL '1 day'
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla ostatniego dnia miesiąca - 2
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month 1 day'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month'
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla pierwszygo dnia miesiąca - 3
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '3 month'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '3 month' + INTERVAL '1 day'
    )
    AND EXISTS (
        SELECT 1
        FROM measures AS measures_inner
        WHERE measures_inner.city_id = measures.city_id
        -- czy istnieje pomiar dla ostatniego dnia miesiąca - 3
        AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 month 1 day'
        AND timestamp <  DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 month'
    )
    AND timestamp >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '3 month'
    AND timestamp <  DATE_TRUNC('month', CURRENT_DATE)
    GROUP BY city_id
), rising_3m_cities AS (
    SELECT city_id,
           (co_1m > co_2m AND co_2m > co_3m) AS rising_co,
           (pm10_1m > pm10_2m AND pm10_2m > pm10_3m) AS rising_pm10
    FROM last_3m_cities
)
SELECT c.region_id, rc.city_id, c.name city_name, rc.rising_co, rc.rising_pm10
FROM rising_3m_cities AS rc
JOIN cities AS c ON c.id = rc.city_id
WHERE rc.rising_co OR rc.rising_pm10;